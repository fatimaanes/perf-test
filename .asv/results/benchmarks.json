{
    "benchmarks.CPUBenchmarks.time_cpu_ai_pathfinding": {
        "code": "class CPUBenchmarks:\n    def time_cpu_ai_pathfinding(self, entities):\n        \"\"\"CPU: AI pathfinding calculations\"\"\"\n        paths = []\n        for agent in self.ai_agents[:min(100, len(self.ai_agents))]:\n            # Simulate A* pathfinding\n            start_x, start_y = agent['pos']\n            target_x, target_y = 50.0, 50.0  # Target position\n            distance = math.sqrt((target_x - start_x)**2 + (target_y - start_y)**2)\n            paths.append(distance)\n        return sum(paths)\n\n    def setup(self, entities):\n        self.ai_agents = [{'pos': (random.random()*100, random.random()*100),\n                          'health': random.randint(50, 100),\n                          'target': None} for _ in range(entities)]\n        self.physics_objects = [random.random() * 10 for _ in range(entities)]",
        "min_run_count": 2,
        "name": "benchmarks.CPUBenchmarks.time_cpu_ai_pathfinding",
        "number": 0,
        "param_names": [
            "entities"
        ],
        "params": [
            [
                "1000",
                "5000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "ebf2687177240429f4bc8e1ada16ab4d8874525840f893570fb019c3c324e6f9",
        "warmup_time": -1
    },
    "benchmarks.CPUBenchmarks.time_cpu_audio_processing": {
        "code": "class CPUBenchmarks:\n    def time_cpu_audio_processing(self, entities):\n        \"\"\"CPU: Audio processing\"\"\"\n        audio_samples = []\n        sample_count = min(entities, 2048)  # Audio buffer size\n        for i in range(sample_count):\n            # Simulate audio DSP\n            sample = math.sin(i * 0.1) * math.cos(i * 0.05)\n            audio_samples.append(sample)\n        return audio_samples\n\n    def setup(self, entities):\n        self.ai_agents = [{'pos': (random.random()*100, random.random()*100),\n                          'health': random.randint(50, 100),\n                          'target': None} for _ in range(entities)]\n        self.physics_objects = [random.random() * 10 for _ in range(entities)]",
        "min_run_count": 2,
        "name": "benchmarks.CPUBenchmarks.time_cpu_audio_processing",
        "number": 0,
        "param_names": [
            "entities"
        ],
        "params": [
            [
                "1000",
                "5000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "42c90b3908658544f409a964dab6a7795f980025e9cd22da269a1ba657d63fd3",
        "warmup_time": -1
    },
    "benchmarks.CPUBenchmarks.time_cpu_network_updates": {
        "code": "class CPUBenchmarks:\n    def time_cpu_network_updates(self, entities):\n        \"\"\"CPU: Network synchronization\"\"\"\n        updates = []\n        for i in range(0, min(entities, 64)):  # Max 64 networked entities\n            # Simulate network packet creation\n            update = {'id': i, 'pos': self.ai_agents[i]['pos'],\n                     'health': self.ai_agents[i]['health']}\n            updates.append(hash(str(update)))\n        return updates\n\n    def setup(self, entities):\n        self.ai_agents = [{'pos': (random.random()*100, random.random()*100),\n                          'health': random.randint(50, 100),\n                          'target': None} for _ in range(entities)]\n        self.physics_objects = [random.random() * 10 for _ in range(entities)]",
        "min_run_count": 2,
        "name": "benchmarks.CPUBenchmarks.time_cpu_network_updates",
        "number": 0,
        "param_names": [
            "entities"
        ],
        "params": [
            [
                "1000",
                "5000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "739a0a80c776d65381c7ae96acc8b3f6c30d81d3c7f18bb7dbf353154bd41610",
        "warmup_time": -1
    },
    "benchmarks.CPUBenchmarks.time_cpu_physics_integration": {
        "code": "class CPUBenchmarks:\n    def time_cpu_physics_integration(self, entities):\n        \"\"\"CPU: Physics integration\"\"\"\n        velocities = []\n        for obj_mass in self.physics_objects:\n            # Simulate physics integration\n            acceleration = 9.81  # gravity\n            velocity = obj_mass * acceleration * 0.016  # 60fps timestep\n            velocities.append(velocity)\n        return sum(velocities)\n\n    def setup(self, entities):\n        self.ai_agents = [{'pos': (random.random()*100, random.random()*100),\n                          'health': random.randint(50, 100),\n                          'target': None} for _ in range(entities)]\n        self.physics_objects = [random.random() * 10 for _ in range(entities)]",
        "min_run_count": 2,
        "name": "benchmarks.CPUBenchmarks.time_cpu_physics_integration",
        "number": 0,
        "param_names": [
            "entities"
        ],
        "params": [
            [
                "1000",
                "5000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a1726f5bacf753aca0807bc1d7d5be90413ad0679651c133ee7ce914f76c6cc2",
        "warmup_time": -1
    },
    "benchmarks.FPSBenchmarks.time_fps_animation": {
        "code": "class FPSBenchmarks:\n    def time_fps_animation(self):\n        \"\"\"FPS: Skeletal animation\"\"\"\n        animated = []\n        for i in range(min(200, len(self.visible_entities))):\n            entity_id = self.visible_entities[i]\n            # Simulate bone transformation\n            for bone in range(24):  # 24 bones per character\n                animated.append(entity_id * bone * 0.1)\n        return animated\n\n    def setup(self):\n        self.entities = 1200  # Number of entities to process\n        self.vertices = list(range(self.entities * 3))  # 3 vertices per entity\n        self.transforms = {i: (random.random(), random.random(), random.random())\n                          for i in range(self.entities)}\n        self.visible_entities = [random.randint(0, self.entities-1) for _ in range(800)]",
        "min_run_count": 2,
        "name": "benchmarks.FPSBenchmarks.time_fps_animation",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "4f516af277984ae986db7da408f2d08e5e4b933c025250f7ad6deff7c7777a73",
        "warmup_time": -1
    },
    "benchmarks.FPSBenchmarks.time_fps_culling": {
        "code": "class FPSBenchmarks:\n    def time_fps_culling(self):\n        \"\"\"FPS: View frustum culling\"\"\"\n        visible = []\n        for entity_id in range(self.entities):\n            # Simulate frustum culling calculation\n            if entity_id % 3 == 0:  # Simulate 1/3 visible\n                visible.append(entity_id)\n        return visible\n\n    def setup(self):\n        self.entities = 1200  # Number of entities to process\n        self.vertices = list(range(self.entities * 3))  # 3 vertices per entity\n        self.transforms = {i: (random.random(), random.random(), random.random())\n                          for i in range(self.entities)}\n        self.visible_entities = [random.randint(0, self.entities-1) for _ in range(800)]",
        "min_run_count": 2,
        "name": "benchmarks.FPSBenchmarks.time_fps_culling",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "99673b000f0934413491af10f745cc7d302a08892f54e471b0a55e04ec0161bb",
        "warmup_time": -1
    },
    "benchmarks.FPSBenchmarks.time_fps_physics": {
        "code": "class FPSBenchmarks:\n    def time_fps_physics(self):\n        \"\"\"FPS: Physics simulation\"\"\"\n        collisions = []\n        for i in range(0, len(self.visible_entities)-1):\n            entity1 = self.visible_entities[i]\n            entity2 = self.visible_entities[i+1]\n            # Simulate collision detection\n            distance = abs(entity1 - entity2)\n            if distance < 5:\n                collisions.append((entity1, entity2))\n        return collisions\n\n    def setup(self):\n        self.entities = 1200  # Number of entities to process\n        self.vertices = list(range(self.entities * 3))  # 3 vertices per entity\n        self.transforms = {i: (random.random(), random.random(), random.random())\n                          for i in range(self.entities)}\n        self.visible_entities = [random.randint(0, self.entities-1) for _ in range(800)]",
        "min_run_count": 2,
        "name": "benchmarks.FPSBenchmarks.time_fps_physics",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c013ca15a8f398c0d8ca20037b0d5dbc69a7b0d53babd0a5a10e610e4110b02b",
        "warmup_time": -1
    },
    "benchmarks.FPSBenchmarks.time_fps_rendering": {
        "code": "class FPSBenchmarks:\n    def time_fps_rendering(self):\n        \"\"\"FPS: 3D rendering pipeline\"\"\"\n        result = []\n        for entity_id in self.visible_entities:\n            # Simulate transform calculations\n            if entity_id in self.transforms:\n                x, y, z = self.transforms[entity_id]\n                transformed = (x * 1.5, y * 1.2, z * 0.8)\n                result.append(transformed)\n        return result\n\n    def setup(self):\n        self.entities = 1200  # Number of entities to process\n        self.vertices = list(range(self.entities * 3))  # 3 vertices per entity\n        self.transforms = {i: (random.random(), random.random(), random.random())\n                          for i in range(self.entities)}\n        self.visible_entities = [random.randint(0, self.entities-1) for _ in range(800)]",
        "min_run_count": 2,
        "name": "benchmarks.FPSBenchmarks.time_fps_rendering",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "428fd415578415ee1f7e3fbcce3475246c42884939ed1712d4e6b54451c78799",
        "warmup_time": -1
    },
    "benchmarks.GPUBenchmarks.time_gpu_compute_shaders": {
        "code": "class GPUBenchmarks:\n    def time_gpu_compute_shaders(self):\n        \"\"\"GPU: Compute shader simulation\"\"\"\n        compute_results = []\n        workgroup_size = 64\n        for group in range(len(self.vertices) // workgroup_size):\n            # Simulate parallel compute work\n            group_result = 0\n            for i in range(workgroup_size):\n                idx = group * workgroup_size + i\n                if idx < len(self.vertices):\n                    x, y, z = self.vertices[idx]\n                    group_result += x * y * z\n            compute_results.append(group_result)\n        return compute_results\n\n    def setup(self):\n        self.vertices = [(random.random(), random.random(), random.random())\n                        for _ in range(5000)]\n        self.textures = ['texture_' + str(i) for i in range(200)]\n        self.shader_uniforms = {f'uniform_{i}': random.random() for i in range(64)}",
        "min_run_count": 2,
        "name": "benchmarks.GPUBenchmarks.time_gpu_compute_shaders",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "7b0b99f9e5b164feef160338d20c646cf473dabb1cfbf1deb96c092901d6907a",
        "warmup_time": -1
    },
    "benchmarks.GPUBenchmarks.time_gpu_fragment_processing": {
        "code": "class GPUBenchmarks:\n    def time_gpu_fragment_processing(self):\n        \"\"\"GPU: Fragment shader simulation\"\"\"\n        fragments = []\n        screen_width, screen_height = 1920, 1080\n        sample_count = 1000  # Sample fragments\n        for i in range(sample_count):\n            # Simulate fragment processing\n            x = (i % screen_width) / screen_width\n            y = (i // screen_width) / screen_height\n            # Simulate lighting calculation\n            light_intensity = math.sin(x * math.pi) * math.cos(y * math.pi)\n            fragments.append(light_intensity)\n        return fragments\n\n    def setup(self):\n        self.vertices = [(random.random(), random.random(), random.random())\n                        for _ in range(5000)]\n        self.textures = ['texture_' + str(i) for i in range(200)]\n        self.shader_uniforms = {f'uniform_{i}': random.random() for i in range(64)}",
        "min_run_count": 2,
        "name": "benchmarks.GPUBenchmarks.time_gpu_fragment_processing",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "bbfbfa6e4c845217a36d8af33d0cdd36d0e4f755fa13406129c2a449de0ad899",
        "warmup_time": -1
    },
    "benchmarks.GPUBenchmarks.time_gpu_texture_sampling": {
        "code": "class GPUBenchmarks:\n    def time_gpu_texture_sampling(self):\n        \"\"\"GPU: Texture sampling operations\"\"\"\n        samples = []\n        for texture in self.textures:\n            # Simulate texture coordinate calculations\n            for u in [0.0, 0.5, 1.0]:\n                for v in [0.0, 0.5, 1.0]:\n                    sample = hash(texture + str(u) + str(v)) % 256\n                    samples.append(sample)\n        return samples\n\n    def setup(self):\n        self.vertices = [(random.random(), random.random(), random.random())\n                        for _ in range(5000)]\n        self.textures = ['texture_' + str(i) for i in range(200)]\n        self.shader_uniforms = {f'uniform_{i}': random.random() for i in range(64)}",
        "min_run_count": 2,
        "name": "benchmarks.GPUBenchmarks.time_gpu_texture_sampling",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "2eba400987fc636385113d14c825f80a7b07251a0a9f3ae59aac3fddda7eabc5",
        "warmup_time": -1
    },
    "benchmarks.GPUBenchmarks.time_gpu_vertex_processing": {
        "code": "class GPUBenchmarks:\n    def time_gpu_vertex_processing(self):\n        \"\"\"GPU: Vertex shader simulation\"\"\"\n        transformed_vertices = []\n        for vertex in self.vertices:\n            x, y, z = vertex\n            # Simulate matrix transformation\n            transformed = (x * 1.2 + 0.1, y * 0.8 - 0.2, z * 1.5)\n            transformed_vertices.append(transformed)\n        return transformed_vertices\n\n    def setup(self):\n        self.vertices = [(random.random(), random.random(), random.random())\n                        for _ in range(5000)]\n        self.textures = ['texture_' + str(i) for i in range(200)]\n        self.shader_uniforms = {f'uniform_{i}': random.random() for i in range(64)}",
        "min_run_count": 2,
        "name": "benchmarks.GPUBenchmarks.time_gpu_vertex_processing",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "c09c142e160adb5ca55b8de779440864be4d41665ed0eb930a89577278a2c035",
        "warmup_time": -1
    },
    "benchmarks.MemoryBenchmarks.mem_audio_buffers": {
        "code": "class MemoryBenchmarks:\n    def mem_audio_buffers(self):\n        \"\"\"Memory: Audio buffer allocation\"\"\"\n        # Simulate audio buffer: 48kHz * 2 channels * 4 bytes * 0.1 seconds\n        return [0] * (48000 * 2 * 4)",
        "name": "benchmarks.MemoryBenchmarks.mem_audio_buffers",
        "param_names": [],
        "params": [],
        "type": "memory",
        "unit": "bytes",
        "version": "3ddc447ee986d57af362dfdb98246bd34d5fd6d6c4721f5dbb956fe8a147f297"
    },
    "benchmarks.MemoryBenchmarks.mem_entity_components": {
        "code": "class MemoryBenchmarks:\n    def mem_entity_components(self):\n        \"\"\"Memory: Entity component system\"\"\"\n        # Simulate ECS with 1000 entities, each with multiple components\n        return [{'transform': (0, 0, 0), 'health': 100, 'ai_state': 'idle'}\n                for _ in range(1000)]",
        "name": "benchmarks.MemoryBenchmarks.mem_entity_components",
        "param_names": [],
        "params": [],
        "type": "memory",
        "unit": "bytes",
        "version": "66afed49a7707f8b834da0bcc69cef04c32adb457b23c41bf8f0e67533407c0d"
    },
    "benchmarks.MemoryBenchmarks.mem_shader_cache": {
        "code": "class MemoryBenchmarks:\n    def mem_shader_cache(self):\n        \"\"\"Memory: Compiled shader cache\"\"\"\n        # Simulate shader bytecode cache\n        return {'vertex_shader_' + str(i): [random.randint(0, 255) for _ in range(1024)]\n                for i in range(50)}",
        "name": "benchmarks.MemoryBenchmarks.mem_shader_cache",
        "param_names": [],
        "params": [],
        "type": "memory",
        "unit": "bytes",
        "version": "8b204f0c942b3540b06295194d4f4ec05cd13bbc24e164977464df235f939820"
    },
    "benchmarks.MemoryBenchmarks.mem_texture_cache": {
        "code": "class MemoryBenchmarks:\n    def mem_texture_cache(self):\n        \"\"\"Memory: Texture cache allocation\"\"\"\n        # Simulate 4K texture: 4096x4096x4 bytes (RGBA)\n        return [0] * (4096 * 4096 * 4)",
        "name": "benchmarks.MemoryBenchmarks.mem_texture_cache",
        "param_names": [],
        "params": [],
        "type": "memory",
        "unit": "bytes",
        "version": "b15b97a5a70af350ddee555d1b0bfeea9d3a7ea56cb05b5a9b67178f38dd87a8"
    },
    "benchmarks.MemoryBenchmarks.mem_vertex_buffers": {
        "code": "class MemoryBenchmarks:\n    def mem_vertex_buffers(self):\n        \"\"\"Memory: Vertex buffer allocation\"\"\"\n        # Simulate vertex buffer: 10000 vertices * 12 floats each\n        return [0.0] * (10000 * 12)",
        "name": "benchmarks.MemoryBenchmarks.mem_vertex_buffers",
        "param_names": [],
        "params": [],
        "type": "memory",
        "unit": "bytes",
        "version": "f45b9c53457302bd6a051459c847a66a3b66385cfa83ccf4ad9112c1c79f5877"
    },
    "benchmarks.PerformanceMetrics.track_active_entities": {
        "code": "class PerformanceMetrics:\n    def track_active_entities(self):\n        \"\"\"Track number of active game entities\"\"\"\n        # Simulate entity counting\n        players = 4\n        npcs = 28\n        projectiles = 16\n        particles = 156\n        return players + npcs + projectiles + particles",
        "name": "benchmarks.PerformanceMetrics.track_active_entities",
        "param_names": [],
        "params": [],
        "type": "track",
        "unit": "entities",
        "version": "2a9604ab25278eb4b656c9bf305db24579838ed56f6a0dc2ce93444543c3429c"
    },
    "benchmarks.PerformanceMetrics.track_draw_calls": {
        "code": "class PerformanceMetrics:\n    def track_draw_calls(self):\n        \"\"\"Track number of draw calls per frame\"\"\"\n        # Simulate draw call counting\n        terrain_calls = 12\n        character_calls = 24\n        effect_calls = 18\n        ui_calls = 6\n        return terrain_calls + character_calls + effect_calls + ui_calls",
        "name": "benchmarks.PerformanceMetrics.track_draw_calls",
        "param_names": [],
        "params": [],
        "type": "track",
        "unit": "calls",
        "version": "909c7c245b98b8896602dab2d70b99a4ad4f4f11962579c736932330ae529952"
    },
    "benchmarks.PerformanceMetrics.track_gpu_utilization": {
        "code": "class PerformanceMetrics:\n    def track_gpu_utilization(self):\n        \"\"\"Track GPU utilization percentage\"\"\"\n        # Simulate GPU usage calculation\n        vertex_load = 65\n        fragment_load = 78\n        compute_load = 45\n        avg_utilization = (vertex_load + fragment_load + compute_load) // 3\n        return avg_utilization",
        "name": "benchmarks.PerformanceMetrics.track_gpu_utilization",
        "param_names": [],
        "params": [],
        "type": "track",
        "unit": "percent",
        "version": "a5a836ecb843269fb4df22678abd422c481e11d86b8d93c28a64122a9fc16367"
    },
    "benchmarks.PerformanceMetrics.track_memory_usage_mb": {
        "code": "class PerformanceMetrics:\n    def track_memory_usage_mb(self):\n        \"\"\"Track total memory usage in MB\"\"\"\n        # Simulate memory usage calculation\n        texture_mem = 256  # MB\n        vertex_mem = 64    # MB\n        audio_mem = 32     # MB\n        script_mem = 128   # MB\n        return texture_mem + vertex_mem + audio_mem + script_mem",
        "name": "benchmarks.PerformanceMetrics.track_memory_usage_mb",
        "param_names": [],
        "params": [],
        "type": "track",
        "unit": "MB",
        "version": "b93b5cb41816e4ded1e17ec2a8aa8aa89d023eec7e42b7b9ec8746f43ad111fd"
    },
    "benchmarks.PerformanceMetrics.track_target_fps": {
        "code": "class PerformanceMetrics:\n    def track_target_fps(self):\n        \"\"\"Track target FPS achievement\"\"\"\n        # Simulate checking if we hit 60 FPS target\n        frame_times = [16.67, 15.2, 18.1, 16.9, 15.8]  # milliseconds\n        avg_frame_time = sum(frame_times) / len(frame_times)\n        target_fps = 1000.0 / avg_frame_time\n        return round(target_fps)",
        "name": "benchmarks.PerformanceMetrics.track_target_fps",
        "param_names": [],
        "params": [],
        "type": "track",
        "unit": "fps",
        "version": "a0a9669c21e236e864f3d15f6ee6e2739bc26f1879f60ca9d1a31c23d36fa73a"
    },
    "version": 2
}