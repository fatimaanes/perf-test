{
    "benchmarks.CPUBenchmarks.time_cpu_ai_pathfinding": {
        "code": "class CPUBenchmarks:\n    def time_cpu_ai_pathfinding(self, entities):\n        \"\"\"CPU: AI pathfinding calculations\"\"\"\n        paths = []\n        for agent in self.ai_agents[:min(200, len(self.ai_agents))]:  # More AI agents!\n            # Simulate expensive A* pathfinding with obstacle checking\n            start_x, start_y = agent['pos']\n            target_x, target_y = 50.0, 50.0  # Target position\n            # Expensive pathfinding simulation\n            for obstacle in range(25):  # Check 25 obstacles per agent\n                obstacle_x, obstacle_y = random.random() * 100, random.random() * 100\n                dist_to_obstacle = math.sqrt((obstacle_x - start_x)**2 + (obstacle_y - start_y)**2)\n                if dist_to_obstacle < 10:  # If near obstacle, expensive calculation\n                    paths.append(dist_to_obstacle * math.sin(obstacle) * math.cos(obstacle))\n            distance = math.sqrt((target_x - start_x)**2 + (target_y - start_y)**2)\n            paths.append(distance)\n        return sum(paths)\n\n    def setup(self, entities):\n        self.ai_agents = [{'pos': (random.random()*100, random.random()*100),\n                          'health': random.randint(50, 100),\n                          'target': None} for _ in range(entities)]\n        self.physics_objects = [random.random() * 10 for _ in range(entities)]",
        "min_run_count": 2,
        "name": "benchmarks.CPUBenchmarks.time_cpu_ai_pathfinding",
        "number": 0,
        "param_names": [
            "entities"
        ],
        "params": [
            [
                "1000",
                "5000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "f8506cc1cbd9091766225a9b14da195ba7aa3e3fe131c198316ec238e1318c4b",
        "warmup_time": -1
    },
    "benchmarks.CPUBenchmarks.time_cpu_audio_processing": {
        "code": "class CPUBenchmarks:\n    def time_cpu_audio_processing(self, entities):\n        \"\"\"CPU: Audio processing\"\"\"\n        audio_samples = []\n        sample_count = min(entities, 2048)  # Audio buffer size\n        for i in range(sample_count):\n            # Simulate audio DSP\n            sample = math.sin(i * 0.1) * math.cos(i * 0.05)\n            audio_samples.append(sample)\n        return audio_samples\n\n    def setup(self, entities):\n        self.ai_agents = [{'pos': (random.random()*100, random.random()*100),\n                          'health': random.randint(50, 100),\n                          'target': None} for _ in range(entities)]\n        self.physics_objects = [random.random() * 10 for _ in range(entities)]",
        "min_run_count": 2,
        "name": "benchmarks.CPUBenchmarks.time_cpu_audio_processing",
        "number": 0,
        "param_names": [
            "entities"
        ],
        "params": [
            [
                "1000",
                "5000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "42c90b3908658544f409a964dab6a7795f980025e9cd22da269a1ba657d63fd3",
        "warmup_time": -1
    },
    "benchmarks.CPUBenchmarks.time_cpu_network_updates": {
        "code": "class CPUBenchmarks:\n    def time_cpu_network_updates(self, entities):\n        \"\"\"CPU: Network synchronization\"\"\"\n        updates = []\n        for i in range(0, min(entities, 64)):  # Max 64 networked entities\n            # Simulate network packet creation\n            update = {'id': i, 'pos': self.ai_agents[i]['pos'],\n                     'health': self.ai_agents[i]['health']}\n            updates.append(hash(str(update)))\n        return updates\n\n    def setup(self, entities):\n        self.ai_agents = [{'pos': (random.random()*100, random.random()*100),\n                          'health': random.randint(50, 100),\n                          'target': None} for _ in range(entities)]\n        self.physics_objects = [random.random() * 10 for _ in range(entities)]",
        "min_run_count": 2,
        "name": "benchmarks.CPUBenchmarks.time_cpu_network_updates",
        "number": 0,
        "param_names": [
            "entities"
        ],
        "params": [
            [
                "1000",
                "5000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "739a0a80c776d65381c7ae96acc8b3f6c30d81d3c7f18bb7dbf353154bd41610",
        "warmup_time": -1
    },
    "benchmarks.CPUBenchmarks.time_cpu_physics_integration": {
        "code": "class CPUBenchmarks:\n    def time_cpu_physics_integration(self, entities):\n        \"\"\"CPU: Physics integration\"\"\"\n        velocities = []\n        for obj_mass in self.physics_objects:\n            # Simulate physics integration\n            acceleration = 9.81  # gravity\n            velocity = obj_mass * acceleration * 0.016  # 60fps timestep\n            velocities.append(velocity)\n        return sum(velocities)\n\n    def setup(self, entities):\n        self.ai_agents = [{'pos': (random.random()*100, random.random()*100),\n                          'health': random.randint(50, 100),\n                          'target': None} for _ in range(entities)]\n        self.physics_objects = [random.random() * 10 for _ in range(entities)]",
        "min_run_count": 2,
        "name": "benchmarks.CPUBenchmarks.time_cpu_physics_integration",
        "number": 0,
        "param_names": [
            "entities"
        ],
        "params": [
            [
                "1000",
                "5000",
                "10000"
            ]
        ],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a1726f5bacf753aca0807bc1d7d5be90413ad0679651c133ee7ce914f76c6cc2",
        "warmup_time": -1
    },
    "benchmarks.FPSBenchmarks.time_fps_animation": {
        "code": "class FPSBenchmarks:\n    def time_fps_animation(self):\n        \"\"\"FPS: Skeletal animation\"\"\"\n        animated = []\n        for i in range(min(150, len(self.visible_entities))):  # Reduced animation load\n            entity_id = self.visible_entities[i]\n            # Simulate bone transformation\n            for bone in range(20):  # Optimized to 20 bones per character\n                animated.append(entity_id * bone * 0.1)\n        return animated\n\n    def setup(self):\n        self.entities = 900  # Optimized entity count\n        self.vertices = list(range(self.entities * 3))  # 3 vertices per entity\n        self.transforms = {i: (random.random(), random.random(), random.random())\n                          for i in range(self.entities)}\n        self.visible_entities = [random.randint(0, self.entities-1) for _ in range(800)]",
        "min_run_count": 2,
        "name": "benchmarks.FPSBenchmarks.time_fps_animation",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "d275476de8e9060320acb42ba055bfd8aee7406b0cdc4009500b674e57bc2f1d",
        "warmup_time": -1
    },
    "benchmarks.FPSBenchmarks.time_fps_culling": {
        "code": "class FPSBenchmarks:\n    def time_fps_culling(self):\n        \"\"\"FPS: View frustum culling\"\"\"\n        visible = []\n        for entity_id in range(self.entities):\n            # Simulate frustum culling calculation\n            if entity_id % 3 == 0:  # Simulate 1/3 visible\n                visible.append(entity_id)\n        return visible\n\n    def setup(self):\n        self.entities = 900  # Optimized entity count\n        self.vertices = list(range(self.entities * 3))  # 3 vertices per entity\n        self.transforms = {i: (random.random(), random.random(), random.random())\n                          for i in range(self.entities)}\n        self.visible_entities = [random.randint(0, self.entities-1) for _ in range(800)]",
        "min_run_count": 2,
        "name": "benchmarks.FPSBenchmarks.time_fps_culling",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "9043f2001f0a206127f69ae2b7876d8ae7ec5eb31e4bd8f0a351609b6ab3a648",
        "warmup_time": -1
    },
    "benchmarks.FPSBenchmarks.time_fps_physics": {
        "code": "class FPSBenchmarks:\n    def time_fps_physics(self):\n        \"\"\"FPS: Physics simulation\"\"\"\n        collisions = []\n        for i in range(0, len(self.visible_entities)-1):\n            entity1 = self.visible_entities[i]\n            entity2 = self.visible_entities[i+1]\n            # Simulate collision detection\n            distance = abs(entity1 - entity2)\n            if distance < 5:\n                collisions.append((entity1, entity2))\n        return collisions\n\n    def setup(self):\n        self.entities = 900  # Optimized entity count\n        self.vertices = list(range(self.entities * 3))  # 3 vertices per entity\n        self.transforms = {i: (random.random(), random.random(), random.random())\n                          for i in range(self.entities)}\n        self.visible_entities = [random.randint(0, self.entities-1) for _ in range(800)]",
        "min_run_count": 2,
        "name": "benchmarks.FPSBenchmarks.time_fps_physics",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a3c7c637ceb1cdf562a7136edf9391396d6787fcf1da6331672271a0dd4a23e2",
        "warmup_time": -1
    },
    "benchmarks.FPSBenchmarks.time_fps_rendering": {
        "code": "class FPSBenchmarks:\n    def time_fps_rendering(self):\n        \"\"\"FPS: 3D rendering pipeline\"\"\"\n        result = []\n        for entity_id in self.visible_entities:\n            # Simulate transform calculations\n            if entity_id in self.transforms:\n                x, y, z = self.transforms[entity_id]\n                transformed = (x * 1.5, y * 1.2, z * 0.8)\n                result.append(transformed)\n        return result\n\n    def setup(self):\n        self.entities = 900  # Optimized entity count\n        self.vertices = list(range(self.entities * 3))  # 3 vertices per entity\n        self.transforms = {i: (random.random(), random.random(), random.random())\n                          for i in range(self.entities)}\n        self.visible_entities = [random.randint(0, self.entities-1) for _ in range(800)]",
        "min_run_count": 2,
        "name": "benchmarks.FPSBenchmarks.time_fps_rendering",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "0f24c9db0835c27ab4ded4da2bbd16c095e41328785d1c76870602249543e779",
        "warmup_time": -1
    },
    "benchmarks.GPUBenchmarks.time_gpu_compute_shaders": {
        "code": "class GPUBenchmarks:\n    def time_gpu_compute_shaders(self):\n        \"\"\"GPU: Compute shader simulation\"\"\"\n        compute_results = []\n        workgroup_size = 64\n        for group in range(len(self.vertices) // workgroup_size):\n            # Simulate parallel compute work\n            group_result = 0\n            for i in range(workgroup_size):\n                idx = group * workgroup_size + i\n                if idx < len(self.vertices):\n                    x, y, z = self.vertices[idx]\n                    group_result += x * y * z\n            compute_results.append(group_result)\n        return compute_results\n\n    def setup(self):\n        self.vertices = [(random.random(), random.random(), random.random())\n                        for _ in range(4000)]  # Optimized vertex count\n        self.textures = ['texture_' + str(i) for i in range(200)]\n        self.shader_uniforms = {f'uniform_{i}': random.random() for i in range(64)}",
        "min_run_count": 2,
        "name": "benchmarks.GPUBenchmarks.time_gpu_compute_shaders",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "9ac585da207256a00e64ed02328ed9459a6d65e47654b1d0c63cebeb1a9e7f92",
        "warmup_time": -1
    },
    "benchmarks.GPUBenchmarks.time_gpu_fragment_processing": {
        "code": "class GPUBenchmarks:\n    def time_gpu_fragment_processing(self):\n        \"\"\"GPU: Fragment shader simulation\"\"\"\n        fragments = []\n        screen_width, screen_height = 1920, 1080\n        sample_count = 2000  # More expensive fragment processing!\n        for i in range(sample_count):\n            # Simulate expensive fragment processing with multiple lights\n            x = (i % screen_width) / screen_width\n            y = (i // screen_width) / screen_height\n            # Simulate complex lighting with 8 light sources\n            total_light = 0\n            for light_id in range(8):  # 8 lights per fragment (expensive!)\n                light_x = (light_id * 0.125) % 1.0\n                light_y = (light_id * 0.25) % 1.0\n                distance = math.sqrt((x - light_x)**2 + (y - light_y)**2)\n                attenuation = 1.0 / (1.0 + distance * distance)\n                light_contribution = math.sin(distance * math.pi * 4) * attenuation\n                total_light += light_contribution\n            fragments.append(total_light)\n        return fragments\n\n    def setup(self):\n        self.vertices = [(random.random(), random.random(), random.random())\n                        for _ in range(4000)]  # Optimized vertex count\n        self.textures = ['texture_' + str(i) for i in range(200)]\n        self.shader_uniforms = {f'uniform_{i}': random.random() for i in range(64)}",
        "min_run_count": 2,
        "name": "benchmarks.GPUBenchmarks.time_gpu_fragment_processing",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "858486f7de7910a7ea1e8573beca879a5e367c09c98fcc86249b11931d7f6c07",
        "warmup_time": -1
    },
    "benchmarks.GPUBenchmarks.time_gpu_texture_sampling": {
        "code": "class GPUBenchmarks:\n    def time_gpu_texture_sampling(self):\n        \"\"\"GPU: Texture sampling operations\"\"\"\n        samples = []\n        for texture in self.textures:\n            # Simulate texture coordinate calculations\n            for u in [0.0, 0.5, 1.0]:\n                for v in [0.0, 0.5, 1.0]:\n                    sample = hash(texture + str(u) + str(v)) % 256\n                    samples.append(sample)\n        return samples\n\n    def setup(self):\n        self.vertices = [(random.random(), random.random(), random.random())\n                        for _ in range(4000)]  # Optimized vertex count\n        self.textures = ['texture_' + str(i) for i in range(200)]\n        self.shader_uniforms = {f'uniform_{i}': random.random() for i in range(64)}",
        "min_run_count": 2,
        "name": "benchmarks.GPUBenchmarks.time_gpu_texture_sampling",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "85d0ac276fb7225827cb32b243301ec105219692939fc3de61265c6bca27f4ef",
        "warmup_time": -1
    },
    "benchmarks.GPUBenchmarks.time_gpu_vertex_processing": {
        "code": "class GPUBenchmarks:\n    def time_gpu_vertex_processing(self):\n        \"\"\"GPU: Vertex shader simulation\"\"\"\n        transformed_vertices = []\n        for vertex in self.vertices:\n            x, y, z = vertex\n            # Simulate matrix transformation\n            transformed = (x * 1.2 + 0.1, y * 0.8 - 0.2, z * 1.5)\n            transformed_vertices.append(transformed)\n        return transformed_vertices\n\n    def setup(self):\n        self.vertices = [(random.random(), random.random(), random.random())\n                        for _ in range(4000)]  # Optimized vertex count\n        self.textures = ['texture_' + str(i) for i in range(200)]\n        self.shader_uniforms = {f'uniform_{i}': random.random() for i in range(64)}",
        "min_run_count": 2,
        "name": "benchmarks.GPUBenchmarks.time_gpu_vertex_processing",
        "number": 0,
        "param_names": [],
        "params": [],
        "repeat": 0,
        "rounds": 2,
        "sample_time": 0.01,
        "type": "time",
        "unit": "seconds",
        "version": "a08adffdb4a0901cb2a87df99d0d791d66cfce55b13cefb4d235c15d67ee9b99",
        "warmup_time": -1
    },
    "benchmarks.MemoryBenchmarks.mem_audio_buffers": {
        "code": "class MemoryBenchmarks:\n    def mem_audio_buffers(self):\n        \"\"\"Memory: Audio buffer allocation\"\"\"\n        # Simulate audio buffer: 48kHz * 2 channels * 4 bytes * 0.1 seconds\n        return [0] * (48000 * 2 * 4)",
        "name": "benchmarks.MemoryBenchmarks.mem_audio_buffers",
        "param_names": [],
        "params": [],
        "type": "memory",
        "unit": "bytes",
        "version": "3ddc447ee986d57af362dfdb98246bd34d5fd6d6c4721f5dbb956fe8a147f297"
    },
    "benchmarks.MemoryBenchmarks.mem_entity_components": {
        "code": "class MemoryBenchmarks:\n    def mem_entity_components(self):\n        \"\"\"Memory: Entity component system\"\"\"\n        # Simulate ECS with 1000 entities, each with multiple components\n        return [{'transform': (0, 0, 0), 'health': 100, 'ai_state': 'idle'}\n                for _ in range(1000)]",
        "name": "benchmarks.MemoryBenchmarks.mem_entity_components",
        "param_names": [],
        "params": [],
        "type": "memory",
        "unit": "bytes",
        "version": "66afed49a7707f8b834da0bcc69cef04c32adb457b23c41bf8f0e67533407c0d"
    },
    "benchmarks.MemoryBenchmarks.mem_shader_cache": {
        "code": "class MemoryBenchmarks:\n    def mem_shader_cache(self):\n        \"\"\"Memory: Compiled shader cache\"\"\"\n        # Simulate shader bytecode cache\n        return {'vertex_shader_' + str(i): [random.randint(0, 255) for _ in range(1024)]\n                for i in range(50)}",
        "name": "benchmarks.MemoryBenchmarks.mem_shader_cache",
        "param_names": [],
        "params": [],
        "type": "memory",
        "unit": "bytes",
        "version": "8b204f0c942b3540b06295194d4f4ec05cd13bbc24e164977464df235f939820"
    },
    "benchmarks.MemoryBenchmarks.mem_texture_cache": {
        "code": "class MemoryBenchmarks:\n    def mem_texture_cache(self):\n        \"\"\"Memory: Texture cache allocation\"\"\"\n        # Simulate 4K texture: 4096x4096x4 bytes (RGBA)\n        return [0] * (4096 * 4096 * 4)",
        "name": "benchmarks.MemoryBenchmarks.mem_texture_cache",
        "param_names": [],
        "params": [],
        "type": "memory",
        "unit": "bytes",
        "version": "b15b97a5a70af350ddee555d1b0bfeea9d3a7ea56cb05b5a9b67178f38dd87a8"
    },
    "benchmarks.MemoryBenchmarks.mem_vertex_buffers": {
        "code": "class MemoryBenchmarks:\n    def mem_vertex_buffers(self):\n        \"\"\"Memory: Vertex buffer allocation\"\"\"\n        # Simulate vertex buffer: 10000 vertices * 12 floats each\n        return [0.0] * (10000 * 12)",
        "name": "benchmarks.MemoryBenchmarks.mem_vertex_buffers",
        "param_names": [],
        "params": [],
        "type": "memory",
        "unit": "bytes",
        "version": "f45b9c53457302bd6a051459c847a66a3b66385cfa83ccf4ad9112c1c79f5877"
    },
    "benchmarks.PerformanceMetrics.track_active_entities": {
        "code": "class PerformanceMetrics:\n    def track_active_entities(self):\n        \"\"\"Track number of active game entities\"\"\"\n        # Simulate entity counting\n        players = 4\n        npcs = 28\n        projectiles = 16\n        particles = 156\n        return players + npcs + projectiles + particles",
        "name": "benchmarks.PerformanceMetrics.track_active_entities",
        "param_names": [],
        "params": [],
        "type": "track",
        "unit": "entities",
        "version": "2a9604ab25278eb4b656c9bf305db24579838ed56f6a0dc2ce93444543c3429c"
    },
    "benchmarks.PerformanceMetrics.track_draw_calls": {
        "code": "class PerformanceMetrics:\n    def track_draw_calls(self):\n        \"\"\"Track number of draw calls per frame\"\"\"\n        # Simulate draw call counting\n        terrain_calls = 12\n        character_calls = 24\n        effect_calls = 18\n        ui_calls = 6\n        return terrain_calls + character_calls + effect_calls + ui_calls",
        "name": "benchmarks.PerformanceMetrics.track_draw_calls",
        "param_names": [],
        "params": [],
        "type": "track",
        "unit": "calls",
        "version": "909c7c245b98b8896602dab2d70b99a4ad4f4f11962579c736932330ae529952"
    },
    "benchmarks.PerformanceMetrics.track_gpu_utilization": {
        "code": "class PerformanceMetrics:\n    def track_gpu_utilization(self):\n        \"\"\"Track GPU utilization percentage\"\"\"\n        # Simulate GPU usage calculation\n        vertex_load = 65\n        fragment_load = 78\n        compute_load = 45\n        avg_utilization = (vertex_load + fragment_load + compute_load) // 3\n        return avg_utilization",
        "name": "benchmarks.PerformanceMetrics.track_gpu_utilization",
        "param_names": [],
        "params": [],
        "type": "track",
        "unit": "percent",
        "version": "a5a836ecb843269fb4df22678abd422c481e11d86b8d93c28a64122a9fc16367"
    },
    "benchmarks.PerformanceMetrics.track_memory_usage_mb": {
        "code": "class PerformanceMetrics:\n    def track_memory_usage_mb(self):\n        \"\"\"Track total memory usage in MB\"\"\"\n        # Simulate memory usage calculation\n        texture_mem = 256  # MB\n        vertex_mem = 64    # MB\n        audio_mem = 32     # MB\n        script_mem = 128   # MB\n        return texture_mem + vertex_mem + audio_mem + script_mem",
        "name": "benchmarks.PerformanceMetrics.track_memory_usage_mb",
        "param_names": [],
        "params": [],
        "type": "track",
        "unit": "MB",
        "version": "b93b5cb41816e4ded1e17ec2a8aa8aa89d023eec7e42b7b9ec8746f43ad111fd"
    },
    "benchmarks.PerformanceMetrics.track_target_fps": {
        "code": "class PerformanceMetrics:\n    def track_target_fps(self):\n        \"\"\"Track target FPS achievement\"\"\"\n        # Simulate checking if we hit 60 FPS target\n        frame_times = [16.67, 15.2, 18.1, 16.9, 15.8]  # milliseconds\n        avg_frame_time = sum(frame_times) / len(frame_times)\n        target_fps = 1000.0 / avg_frame_time\n        return round(target_fps)",
        "name": "benchmarks.PerformanceMetrics.track_target_fps",
        "param_names": [],
        "params": [],
        "type": "track",
        "unit": "fps",
        "version": "a0a9669c21e236e864f3d15f6ee6e2739bc26f1879f60ca9d1a31c23d36fa73a"
    },
    "version": 2
}